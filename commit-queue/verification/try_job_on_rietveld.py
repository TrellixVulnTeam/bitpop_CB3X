# coding=utf8
# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
"""Sends patches to the Try server and reads back results.

- RietveldTryJobs contains RietveldTryJob, one per try job on a builder.
- TryRunnerRietveld uses Rietveld to signal and poll job results.
"""

import logging
import re
import time
import urllib2

import buildbot_json
import model
from verification import base

# CQ uses this delay to decide if a triggered job hasn't show up from
# rietveld processing time or if it has gone missing
PROPOGATION_DELAY_S = 3 * 60 * 60

# A build running for longer than this is considered to be timed out.
TIMED_OUT = 6 * 60 * 60


def is_job_expired(revision, timestamp, checkout):
  """Returns False if the job result is still somewhat valid.

  A job that occured more than 4 days ago or more than 200 commits behind
  is 'expired'.
  """
  if timestamp < (time.time() - 4*24*60*60):
    return True
  if checkout.revisions(revision, None) >= 200:
    return True
  return False


class RietveldTryJobPending(model.PersistentMixIn):
  """Represents a pending try job for a pending commit that we care about.
  """
  builder = unicode
  revision = (None, unicode, int)
  requested_steps = list
  clobber = bool
  # Number of retries for this configuration. Initial try is 1.
  tries = int
  init_time = float

  def __init__(self, **kwargs):
    super(RietveldTryJobPending, self).__init__(init_time=time.time(), **kwargs)


class RietveldTryJob(model.PersistentMixIn):
  """Represents a try job for a pending commit that we care about.

  This data can be regenerated by parsing all the try job names but it is a bit
  hard on the try server.
  """
  builder = unicode
  build = int
  revision = (None, unicode, int)
  requested_steps = list
  # The timestamp when the build started. buildbot_json returns int.
  started = int
  steps_passed = list
  steps_failed = list
  clobber = bool
  completed = bool
  # Number of retries for this configuration. Initial try is 1.
  tries = int
  parent_key = (None, unicode)
  init_time = float

  def __init__(self, **kwargs):
    super(RietveldTryJob, self).__init__(init_time=time.time(), **kwargs)

  @property
  def result(self):
    if self.steps_failed:
      return buildbot_json.FAILURE
    if self.completed:
      return buildbot_json.SUCCESS
    return None

  def stewed(self):
    """Returns True if this job has had time to propagate."""
    return time.time() - self.init_time > PROPOGATION_DELAY_S

  def is_hung(self):
    """Returns True if this job has been running for too long."""
    assert self.started
    return time.time() - self.started > TIMED_OUT

  def __eq__(self, rhs):
    for i in self._persistent_members():
      if getattr(self, i) != getattr(rhs, i):
        return False
    return True

  def __ne__(self, rhs):
    return not self.__eq__(rhs)


class RietveldTryJobs(base.IVerifierStatus):
  """A set of try jobs that were sent for a specific patch.

  Multiple concurrent try jobs can be sent on a single builder. For example, a
  previous valid try job could have been triggered by the user but was not
  completed so another was sent with the missing tests.
  Also, a try job is sent as soon as a test failure is detected.
  """
  # An dict of RietveldTryJob objects per key.
  try_jobs = dict
  # The try job keys we ignore because they can't be used to give a good
  # signal: either they are too old (old revision) or they were not triggerd
  # by Rietveld, so we don't know if the diff is 100% good.
  irrelevant = list
  # When NOTRY=true is specified.
  skipped = bool
  # Mapping from builders to list of tests.
  builders_and_tests = dict
  # Mapping from triggered builders to their parent.  Do not change this
  # directly.  Instead use self.update_triggered_builders()
  triggered_builders = dict
  # Jobs that have been sent but are not found yet. Likely a builder is fully
  # utilized or the try server hasn't polled Rietveld yet. list of
  # RietveldTryJobPending() instances.
  pendings = list

  def update_triggered_builders(self, new_triggered_builders):
    """Add triggered builders to verification list.

    Args:
      new_triggered_builders: list of (builder, parent_name, list of tests)
    """
    for builder, parent, tests in new_triggered_builders:
      if builder in self.triggered_builders:
        logging.warning(
            'Triggered builder %s already present, skipping add', builder)
        continue

      self.builders_and_tests.setdefault(parent, [])
      self.builders_and_tests.setdefault(builder, [])
      for test in tests:
        if not test in self.builders_and_tests[builder]:
          self.builders_and_tests[builder].append(test)
      self.triggered_builders[builder] = parent

  def get_state(self):
    if self.skipped or not self.tests_waiting_for_result():
      return base.SUCCEEDED
    if (self.pendings or
        not all(t.completed for t in self.try_jobs.itervalues())):
      return base.PROCESSING
    logging.debug('Not pending, all %d jobs completed' % len(self.try_jobs))
    return base.FAILED

  def parents_with_trigger_pending(self):
    """Returns the set of active parent jobs that might trigger a slave."""

    parents_with_detected_children = set()
    for key, job in self.try_jobs.iteritems():
      if job.builder in self.triggered_builders:
        assert job.parent_key in self.try_jobs, "%s parent not present" % key
        parents_with_detected_children.add(job.parent_key)

    parents = set(self.triggered_builders.itervalues())
    trigger_pending = set()

    for key, job in self.try_jobs.iteritems():
      if job.builder not in parents or key in parents_with_detected_children:
        continue
      if job.completed and 'trigger' in job.steps_passed:
        if job.stewed():
          logging.info('Trigger passed on %s(%s) but no child detected!',
                       job.builder, key)
        else:
          trigger_pending.add(job.builder)
      elif not job.completed and 'trigger' not in job.steps_failed:
        trigger_pending.add(job.builder)

    return trigger_pending

  def tests_need_to_be_run(self):
    """Returns which tests need to be run.

    These are the tests that are not pending on any try job, either running or
    in the pending list.
    """
    # What needs to be run.
    all_tests = dict(
        (builder, set(tests))
        for builder, tests in self.builders_and_tests.iteritems())

    # Removes what was run and almost to be run, e.g. the build is running.
    for try_job in self.try_jobs.itervalues():
      if try_job.builder in all_tests:
        all_tests[try_job.builder] -= set(try_job.steps_passed)
        # If it was requested but still not run, do not add it either. Only do
        # that if the job hasn't completed yet to catch issues like: a test was
        # requested on a builder but the test was not run because it is not in
        # the BuildFactory for the Builder.
        if not try_job.completed:
          # Special case jobs discovered by CQ that it did not send. Wait for
          # these jobs to complete rather than trying to interpret the filter
          if try_job.requested_steps == []:
            assert try_job.started
            all_tests[try_job.builder].clear()
          else:
            to_be_run = (
                set(try_job.requested_steps) - set(try_job.steps_failed))
            all_tests[try_job.builder] -= to_be_run

    pending_parents = self.parents_with_trigger_pending()
    for builder, tests in all_tests.iteritems():
      if builder in self.triggered_builders and tests:
        # triggered tester needs another run.  If the builder isn't going,
        # or pending, or recently finished, we will trigger another job.
        parent = self.triggered_builders[builder]
        if parent not in pending_parents:
          all_tests[parent].update(tests)

    # Removes what is queued to be run but hasn't started yet.
    for try_job in self.pendings:
      if try_job.builder in all_tests:
        all_tests[try_job.builder] -= set(try_job.requested_steps)

    return dict(
        (builder, sorted(tests)) for builder, tests in all_tests.iteritems()
        if tests and builder not in self.triggered_builders)

  def tests_waiting_for_result(self):
    """Returns the tests that we are waiting for results on pending or running
    builds.
    """
    all_tests = dict(
        (builder, set(tests))
        for builder, tests in self.builders_and_tests.iteritems())

    # Removes what was run.
    for try_job in self.try_jobs.itervalues():
      if try_job.builder in all_tests:
        all_tests[try_job.builder] -= set(try_job.steps_passed)

    return dict(
        (builder, list(tests)) for builder, tests in all_tests.iteritems()
        if tests)

  @staticmethod
  def filter_jobs(try_job_results, current_irrelevant_keys, status):
    """Does preliminary filtering of rietveld try job list."""

    irrelevant = set(current_irrelevant_keys)
    try_jobs_with_props = []
    for result in try_job_results:
      key = result['key']
      assert key
      if key in current_irrelevant_keys:
        continue
      builder = result['builder']
      try:
        buildnumber = int(result['buildnumber'])
      except (TypeError, ValueError):
        continue
      if buildnumber < 0:
        logging.debug('Ignoring %s/%d; invalid', builder, buildnumber)
        irrelevant.add(key)
        continue

      # Constructing the object itself doesn't throw an exception, it's reading
      # its properties that throws.
      build = status.builders[builder].builds[buildnumber]
      try:
        props = build.properties_as_dict
      except IOError:
        logging.info(
            'Build %s/%s is not on the try server anymore',
            builder, buildnumber)
        irrelevant.add(key)
        continue
      parent_key = props.get('parent_try_job_key')
      if parent_key:
        # Triggered build
        key = '%s/%d_triggered_%s' % (builder, buildnumber, parent_key)
      elif props.get('try_job_key') != key:
        # not triggered, not valid
        logging.debug(
            'Ignoring %s/%d; not from rietveld', builder, buildnumber)
        irrelevant.add(key)
        continue

      try_jobs_with_props.append((key, parent_key, builder,
                                  build, buildnumber, props))

    # Sort the non-triggered builds first so triggered jobs
    # can expect their parent to be added to self.try_jobs
    try_jobs_with_props.sort(key=lambda tup: tup[1])

    return try_jobs_with_props, list(irrelevant)

  def update_jobs_from_rietveld(self, owner, data, status, checkout):
    """Retrieves the jobs statuses from rietveld and updates its state.

    Args:
      owner: Owner of the CL.
      data: Patchset properties as returned from Rietveld.
      status: An AsyncPush instance to chromium-status.
      checkout: A depot_tools' Checkout instance.

    Returns:
      Keys which were updated.
    """
    updated = []
    try_job_results = data.get('try_job_results', [])
    logging.debug('Found %d entries', len(try_job_results))

    try_jobs_with_props, self.irrelevant = RietveldTryJobs.filter_jobs(
        try_job_results, self.irrelevant, status)

    for (key, parent_key, builder,
         build, buildnumber, properties) in try_jobs_with_props:
      if self._update_try_job_status(
          checkout, key, parent_key, builder, build, buildnumber, properties):
        updated.append(key)
    self._strip_lost_pending_request(owner, status)
    return updated

  def _update_try_job_status(
      self, checkout, key, parent_key, builder, build, buildnumber, properties):
    """Updates status of a specific try job.

    Returns True if it was updated."""
    if key in self.irrelevant:
      logging.debug('Ignoring %s/%d; irrelevant', builder, buildnumber)
      return False
    if parent_key:
      if builder not in self.triggered_builders:
        logging.debug('Ignoring %s, not in triggered list', key)
        return False
      if parent_key not in self.try_jobs:
        logging.debug('Ignoring %s, parent unknown', key)
        return False

    requested_steps = []
    # Set it to 0 as the default value since when the job is new and previous
    # try jobs are found, we don't want to count them as tries.
    tries = 0
    job = self.try_jobs.get(key)
    if job:
      if job.completed:
        logging.debug('Ignoring %s/%d; completed', builder, buildnumber)
        return False
      else:
        if job.is_hung():
          # Flush it and start over.
          self.irrelevant.append(key)
          del self.try_jobs[key]
          return False
        requested_steps = job.requested_steps
        tries = job.tries
    else:
      # This try job is new. See if we triggered it previously by
      # looking in self.pendings.
      for pending_job in self.pendings[:]:
        if pending_job.builder == builder:
          # Reuse its item.
          requested_steps = pending_job.requested_steps
          tries = pending_job.tries
          self.pendings.remove(pending_job)
          break
      else:
        # Is this a good build? It must not be too old and triggered by
        # rietveld.
        if is_job_expired(build.revision, build.start_time, checkout):
          logging.debug('Ignoring %s/%d; expired', builder, buildnumber)
          self.irrelevant.append(key)
          return False

    passed = [s.name for s in build.steps if s.simplified_result]
    failed = [s.name for s in build.steps if s.simplified_result is False]
    # The steps in neither passed or failed were skipped.
    new_job = RietveldTryJob(
        builder=builder,
        build=buildnumber,
        revision=build.revision,
        requested_steps=requested_steps,
        started=build.start_time,
        steps_passed=passed,
        steps_failed=failed,
        clobber=bool(properties.get('clobber')),
        completed=build.completed,
        tries=tries,
        parent_key=parent_key)
    if job and job == new_job:
      return False
    logging.info(
        'Job update: %s: %s/%d',
        properties.get('issue'),
        builder,
        buildnumber)
    self.try_jobs[key] = new_job
    return key

  def _strip_lost_pending_request(self, owner, status):
    """Looks if all pending jobs are still pending.

    They could have been cancelled, or the TS could have failed triggering them,
    or the TS could have restarted and cleared its pending queue.
    """
    now = time.time()
    for pending_job in self.pendings[:]:
      # It must have been triggered more than 5 minutes ago, to give the time
      # for Rietveld or the Try Server to have hickups, like if Rietveld is
      # broken by an upgrade, the Try Server is being harvest or restarted, etc.
      if (now - pending_job.init_time) < 5*60:
        continue

      # Do not fetch preemptively to not fetch when not needed.
      pending_builds = status.builders[pending_job.builder].pending_builds.data
      if not pending_builds:
        self.pendings.remove(pending_job)
        continue

      # Sadly, the build properties are not exposed so we have to use
      # heuristics. Look for a pending build with:
      # 1. author match
      # 2. hasPatch is not True
      for pending_build in pending_builds:
        if pending_build.get('hasPatch'):
          continue
        changes = pending_build.get('source', {}).get('changes', [])
        if len(changes) != 1:
          continue
        change = changes[0]
        if change.get('who') == owner:
          # closeenough
          break
      else:
        # The job was not found, delete.
        self.pendings.remove(pending_job)

  def why_not(self):
    waiting = self.tests_waiting_for_result()
    if waiting:
      out = 'Waiting for the following jobs:\n'
      for builder in sorted(waiting):
        out += '  %s: %s\n' % (builder, ','.join(waiting[builder]))
      return out


class TryRunnerRietveld(base.VerifierCheckout):
  """Stateless communication with a try server.

  Uses Rietveld to trigger the try job and reads try job status with the json
  API..

  Analysis goes as following:
  - compile step itself is not flaky. compile.py already takes care of most
    flakiness and clobber build is done by default. If compile step fails, try
    again with clobber=True
  - test steps are flaky and can be retried as necessary.

  1. For each existing try jobs from rietveld.
    1. Fetch result from try server.
    2. If try job was generated from rietveld;
      1. If not is_job_expired();
        1. Skip any scheduled test that succeeded on this builder.
  2. For each builder with tests scheduled;
    1. If no step waiting to be triggered, skip this builder completely.
  2. For each non succeeded job;
    1. Send try jobs to rietveld.

  Note: It needs rietveld, hence it uses VerifierCheckout, but it doesn't need a
  checkout.
  """
  name = 'try job rietveld'

  # Only updates a job status once every 60 seconds.
  update_latency = 60

  def __init__(
      self, context_obj, try_server_url, commit_user,
      builders_and_tests, triggered_builders_and_tests,
      ignored_steps, solution):
    super(TryRunnerRietveld, self).__init__(context_obj)
    self.try_server_url = try_server_url.rstrip('/')
    self.commit_user = commit_user
    # TODO(maruel): Have it be overridden by presubmit_support.DoGetTrySlaves.
    self.builders_and_tests = builders_and_tests
    self.triggered_builders_and_tests = triggered_builders_and_tests
    self.ignored_steps = set(ignored_steps)
    # Time to poll the Try Server, and not Rietveld.
    self.last_update = time.time() - self.update_latency
    self.solution = solution
    self.status = buildbot_json.Buildbot(self.try_server_url)

  def verify(self, pending):
    """Sends a try job to the try server and returns a RietveldTryJob list."""
    jobs = pending.verifications.setdefault(self.name, RietveldTryJobs())
    if self._is_skip_try_job(pending):
      # Do not run try job for it.
      jobs.skipped = True
      return

    # Overridde any previous list from the last restart.
    jobs.builders_and_tests = self.builders_and_tests
    jobs.update_triggered_builders(self.triggered_builders_and_tests)

    # First, update the status of the current try jobs on Rietveld.
    self.status.discard()
    self._update_jobs_from_rietveld(pending, jobs)

    # Add anything that is missing.
    self._send_jobs(pending, jobs)

    # Slightly postpone next check.
    self.last_update = min(
        time.time(), self.last_update + (self.update_latency / 4))

  def update_status(self, queue):
    """Grabs the current status of all try jobs and update self.queue.

    Note: it would be more efficient to be event based.
    """
    if not queue:
      logging.debug('The list is empty, nothing to do')
      return

    if time.time() - self.last_update < self.update_latency:
      logging.debug('TS: Throttling updates')
      return
    self.last_update = time.time()

    self.status.discard()
    for pending, jobs in self.loop(queue, RietveldTryJobs, True):
      for updated_key in self._update_jobs_from_rietveld(pending, jobs):
        self._handle_try_job(pending, jobs, jobs.try_jobs[updated_key])
      # Send any necessary job. Noop if not needed.
      self._send_jobs(pending, jobs)

  def _send_jobs(self, pending, jobs):
    """Prepares the RietveldTryJobs instance |jobs| to send try jobs to the try
    server.
    """
    if jobs.error_message:
      # Too late.
      return
    remaining = jobs.tests_need_to_be_run()
    if not remaining:
      return
    # Send them in order to simplify testing.
    for builder in sorted(remaining):
      tests = remaining[builder]
      # Find if there was a previous try.
      previous_jobs = [
        job for job in jobs.try_jobs.itervalues()
        if job.builder == builder
      ]
      if previous_jobs:
        tries = max(job.tries for job in previous_jobs)
        clobber = max(
            (job.clobber or 'compile' in job.steps_failed)
            for job in previous_jobs)
      else:
        tries = 0
        clobber = False
      if tries > 4:
        # Fail safe.
        revision = max(job.revision for job in previous_jobs)
        jobs.error_message = (
            ('The commit queue went berserk retrying too often for a\n'
             'seemingly flaky test. Builder is %s, revision is %s'
              ) % (builder, revision))
        continue

      # Do one request per builder so each can have a different 'clobber'
      # setting.
      logging.debug(
          'Sending job %s for %s: %s', pending.issue, builder, ','.join(tests))
      try:
        self.context.rietveld.trigger_try_jobs(
            pending.issue, pending.patchset, 'CQ', clobber, 'HEAD',
            {builder: tests})
      except urllib2.HTTPError as e:
        if e.code == 400:
          # This probably mean a new patchset was uploaded since the last poll,
          # so it's better to drop the CL.
          jobs.error_message = 'Failed to trigger a try job on %s\n%s' % (
              builder, e)
          return
        else:
          raise
      jobs.pendings.append(
          RietveldTryJobPending(
              builder=builder,
              revision=None,
              requested_steps=tests,
              clobber=clobber,
              tries=tries + 1))
      # Update the status on the AppEngine status to signal a new try job was
      # sent.
      info = {
        'builder': builder,
        'clobber': clobber,
        'job_name': 'CQ',
        'revision': None, #revision,
      }
      self.send_status(pending, info)

  def _build_status_url(self, job):
    """Html url for this try job."""
    assert job.build is not None, str(job)
    return '%s/buildstatus?builder=%s&number=%s' % (
        self.try_server_url, job.builder, job.build)

  def _handle_try_job(self, pending, jobs, job):
    """Handles a try job that recently got activity.

    Decides what it should do now.
    """
    logging.debug('_handle_try_job(%s/%s)', job.builder, job.build)
    build = self.status.builders[job.builder].builds[job.build]
    # Signal to the dashboard a try job completed.
    info = {
      'build': job.build,
      'builder': job.builder,
      'duration': build.duration,
      'job_name': 'CQ',
      'result': job.result,
      'revision': job.revision,
      'url': self._build_status_url(job),
    }
    self.send_status(pending, info)

    # Figure out steps that should be retried for this builder.
    retry = jobs.tests_need_to_be_run().get(job.builder, [])
    if not retry:
      return
    if job.tries > 2:
      jobs.error_message = 'Retried try job too often on %s for step(s) %s' % (
          job.builder, ', '.join(retry))
      logging.info(jobs.error_message)
    elif 'update' in job.steps_failed:
      jobs.error_message = (
          'Step "update" is always a major failure.\n'
          'Look at the try server FAQ for more details.')
      logging.info(jobs.error_message)
    elif 'compile' in job.steps_failed and job.clobber:
      jobs.error_message = (
          'Sorry for I got bad news for ya.\n'
          'Compile failed with a clobber build on %s.\n'
          '%s\n'
          'Your code is likely broken or HEAD is junk. Please ensure your\n'
          'code is not broken then alert the build sheriffs.\n'
          'Look at the try server FAQ for more details.') % (
              job.builder,
              self._build_status_url(job))
      logging.info(jobs.error_message)

  @staticmethod
  def _is_skip_try_job(pending):
    """Returns True if a description contains NOTRY=true."""
    match = re.search(r'^NOTRY=(.*)$', pending.description, re.MULTILINE)
    return match and match.group(1).lower() == 'true'

  def _update_jobs_from_rietveld(self, pending, jobs):
    """Grabs data from Rietveld and pass it to
    RietveldTryJobs.update_jobs_from_rietveld().
    """
    data = self.context.rietveld.get_patchset_properties(
        pending.issue, pending.patchset)
    return jobs.update_jobs_from_rietveld(
        pending.owner, data, self.status, self.context.checkout)
